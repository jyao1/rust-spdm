// Copyright (c) 2021 Intel Corporation
//
// SPDX-License-Identifier: BSD-2-Clause-Patent

use serde::Deserialize;
use std::assert;
use std::env;
use std::io::Write;
use std::path::Path;
use std::{fs, fs::File};

#[derive(Debug, PartialEq, Deserialize)]
struct SpdmConfig {
    max_version_count: usize,
    algo_config: SpdmAlgoConfig,
    cert_config: SpdmCertConfig,
    max_opaque_size: usize,
    psk_config: SpdmPskConfig,
    vendor_defined_config: SpdmVendorDefinedConfig,
    max_session_count: usize,
    max_msg_buffer_size: usize,
    data_transfer_size: usize,
    max_spdm_msg_size: usize,
    heartbeat_period_value: u8,
    secure_spdm_version: u8,
}

impl SpdmConfig {
    fn validate_content(&self) {
        // All rust fixed-size arrays require non-negative compile-time constant sizes.
        // This will be checked by the compiler thus no need to check again here.

        // Check if meet SPDM requirements.
        assert!(self.max_opaque_size < 1024);

        // TODO: add more sanity checks if needed.
    }
}

#[derive(Debug, PartialEq, Deserialize)]
struct SpdmAlgoConfig {
    max_ext_asym_algo_count: usize,
    max_ext_hash_algo_count: usize,
    max_algo_struct_count: usize,
    max_ext_algo_struct_count: usize,
}

#[derive(Debug, PartialEq, Deserialize)]
struct SpdmCertConfig {
    max_cert_chain_data_size: usize,
}

#[derive(Debug, PartialEq, Deserialize)]
struct SpdmPskConfig {
    max_psk_context_size: usize,
    max_psk_hint_size: usize,
}

#[derive(Debug, PartialEq, Deserialize)]
struct SpdmVendorDefinedConfig {
    max_vendor_defined_vendor_id_len: usize,
}

macro_rules! TEMPLATE {
    () => {
"// Copyright (c) 2021 Intel Corporation
//
// SPDX-License-Identifier: BSD-2-Clause-Patent
//
// Automatically generated by build scripts.
// It is not intended for manual editing.
// Please kindly configure via etc/config.json instead.

/// This is used in SpdmVersionResponsePayload
pub const MAX_SPDM_VERSION_COUNT: usize = {ver_cnt};

/// This is used in SpdmNegotiateAlgorithmsRequestPayload / SpdmAlgorithmsResponsePayload
pub const MAX_SPDM_EXTEND_ASYM_ALGO_COUNT: usize = {ext_asym_algo_cnt};
pub const MAX_SPDM_EXTEND_HASH_ALGO_COUNT: usize = {ext_hash_algo_cnt};
pub const MAX_SPDM_ALG_STRUCT_COUNT: usize = {algo_struct_cnt};
pub const MAX_SPDM_EXTEND_ALG_STRUCT_COUNT: usize = {ext_algo_struct_cnt};

/// This is used in SpdmCertChainData without SpdmCertChainHeader.
pub const MAX_SPDM_CERT_CHAIN_DATA_SIZE: usize = {cert_chain_data_sz}; // 0x1000;

/// This is used in SpdmOpaqueStruct <- SpdmChallengeAuthResponsePayload / SpdmMeasurementsResponsePayload
/// It should be smaller than 1024
pub const MAX_SPDM_OPAQUE_SIZE: usize = {opaque_sz};

/// This is used in SpdmPskExchangeRequestPayload / SpdmPskExchangeResponsePayload
/// It should be no smaller than negoatiated DIGEST SIZE.
pub const MAX_SPDM_PSK_CONTEXT_SIZE: usize = {psk_ctx_sz};

/// This is used in SpdmPskExchangeRequestPayload / SpdmPskExchangeResponsePayload
pub const MAX_SPDM_PSK_HINT_SIZE: usize = {psk_hint_sz};

/// This is used in SpdmContext
pub const MAX_SPDM_SESSION_COUNT: usize = {session_cnt};

/// This is used in SpdmRuntimeInfo. max cached size
pub const MAX_SPDM_MESSAGE_BUFFER_SIZE: usize = {msg_buf_sz}; // 0x1200

/// This is used in Transport, SPDM 1.2
pub const DATA_TRANSFER_SIZE: usize = {trans_sz}; // MAX_SPDM_MESSAGE_BUFFER_SIZE + 0x100(For upper layer headers)

/// SPDM 1.2
pub const MAX_SPDM_MSG_SIZE: usize = {max_spdm_mgs_sz}; // set to equal to DATA_TRANSFER_SIZE @todo

/// This is used in SpdmMeasurementRecordStructure
/// It should be MAX_SPDM_MSG_SIZE - (42 + L + OpaqueDataLength + SigLen) + L
pub const MAX_SPDM_MEASUREMENT_VALUE_LEN: usize = MAX_SPDM_MSG_SIZE - 42 - 0x100 - 96; // 0x100 for OpaqueDataLength

/// This is used in vendor defined message transport
pub const MAX_SPDM_VENDOR_DEFINED_VENDOR_ID_LEN: usize = {vendor_id_len};

/// This is used by responder to specify the heartbeat period
/// 0 represents either Heartbeat is not supported or
/// heartbeat is not desired on a session
pub const HEARTBEAT_PERIOD: u8 = {heartbeat_period};

/// This is used by responder
pub const SECURE_SPDM_VERSION: u8 = {secure_spdm_version};
"
};
}

const SPDM_CONFIG_ENV: &str = "SPDM_CONFIG";
const SPDM_CONFIG_JSON_DEFAULT_PATH: &str = "etc/config.json";
const SPDM_CONFIG_RS_OUT_DIR: &str = "src";
const SPDM_CONFIG_RS_OUT_FILE_NAME: &str = "config.rs";

fn main() {
    // Read and parse the SPDM configuration file.
    let spdm_config_json_file_path =
        env::var(SPDM_CONFIG_ENV).unwrap_or_else(|_| SPDM_CONFIG_JSON_DEFAULT_PATH.to_string());
    let spdm_config_json_file =
        File::open(spdm_config_json_file_path).expect("The SPDM configuration file does not exist");
    let spdm_config: SpdmConfig = serde_json::from_reader(spdm_config_json_file)
        .expect("It is not a valid SPDM configuration file.");

    // Do sanity checks.
    spdm_config.validate_content();

    // Generate config .rs file from the template and JSON inputs, then write to fs.
    let mut to_generate = Vec::new();
    write!(
        &mut to_generate,
        TEMPLATE!(),
        ver_cnt = spdm_config.max_version_count,
        ext_asym_algo_cnt = spdm_config.algo_config.max_ext_asym_algo_count,
        ext_hash_algo_cnt = spdm_config.algo_config.max_ext_hash_algo_count,
        algo_struct_cnt = spdm_config.algo_config.max_algo_struct_count,
        ext_algo_struct_cnt = spdm_config.algo_config.max_ext_algo_struct_count,
        cert_chain_data_sz = spdm_config.cert_config.max_cert_chain_data_size,
        opaque_sz = spdm_config.max_opaque_size,
        psk_ctx_sz = spdm_config.psk_config.max_psk_context_size,
        psk_hint_sz = spdm_config.psk_config.max_psk_hint_size,
        session_cnt = spdm_config.max_session_count,
        msg_buf_sz = spdm_config.max_msg_buffer_size,
        trans_sz = spdm_config.data_transfer_size,
        max_spdm_mgs_sz = spdm_config.max_spdm_msg_size,
        vendor_id_len = spdm_config
            .vendor_defined_config
            .max_vendor_defined_vendor_id_len,
        heartbeat_period = spdm_config.heartbeat_period_value,
        secure_spdm_version = spdm_config.secure_spdm_version,
    )
    .expect("Failed to generate configuration code from the template and JSON config");

    let dest_path = Path::new(SPDM_CONFIG_RS_OUT_DIR).join(SPDM_CONFIG_RS_OUT_FILE_NAME);
    fs::write(dest_path, to_generate).unwrap();

    // Re-run the build script if the files at the given paths or envs have changed.
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=../Cargo.lock");
    println!("cargo:rerun-if-changed={}", SPDM_CONFIG_JSON_DEFAULT_PATH);
    println!("cargo:rerun-if-env-changed={}", SPDM_CONFIG_ENV);
}
